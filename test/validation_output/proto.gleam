//// Generated by Protozoa from test/proto/well_known.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m protozoa
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/dict
import gleam/list
import gleam/option.{None, Some}
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type EventMessage {
  EventMessage(
    event_name: String,
    occurred_at: Timestamp,
    duration: Duration,
    update_mask: FieldMask,
  )
}

pub type ServiceResponseResponse {
  Data(EventMessage)
  EmptyData(Empty)
}

pub type ServiceResponse {
  ServiceResponse(response: option.Option(ServiceResponseResponse))
}

pub type Duration {
  Duration(seconds: Int, nanos: Int)
}

pub type Empty {
  Empty
}

pub type FieldMask {
  FieldMask(paths: List(String))
}

pub type Timestamp {
  Timestamp(seconds: Int, nanos: Int)
}

pub fn encode_serviceresponse(serviceresponse: ServiceResponse) -> BitArray {
  encode.message([
    case serviceresponse.response {
      Some(oneof_value) -> {
        case oneof_value {
          Data(value) ->
            encode.field(
              1,
              wire.LengthDelimited,
              encode.length_delimited(encode_eventmessage(value)),
            )
          EmptyData(value) ->
            encode.field(
              2,
              wire.LengthDelimited,
              encode.length_delimited(encode_empty(value)),
            )
        }
      }
      None -> <<>>
    },
  ])
}

pub fn encode_eventmessage(eventmessage: EventMessage) -> BitArray {
  encode.message([
    encode.string_field(1, eventmessage.event_name),
    encode.field(
      2,
      wire.LengthDelimited,
      encode.length_delimited(encode_timestamp(eventmessage.occurred_at)),
    ),
    encode.field(
      3,
      wire.LengthDelimited,
      encode.length_delimited(encode_duration(eventmessage.duration)),
    ),
    encode.field(
      4,
      wire.LengthDelimited,
      encode.length_delimited(encode_fieldmask(eventmessage.update_mask)),
    ),
  ])
}

pub fn encode_duration(duration: Duration) -> BitArray {
  encode.message([
    encode.int64_field(1, duration.seconds),
    encode.int32_field(2, duration.nanos),
  ])
}

pub fn encode_empty(_empty: Empty) -> BitArray {
  encode.message([])
}

pub fn encode_fieldmask(fieldmask: FieldMask) -> BitArray {
  let paths_fields =
    list.map(fieldmask.paths, fn(v) { encode.string_field(1, v) })
  encode.message(paths_fields)
}

pub fn encode_timestamp(timestamp: Timestamp) -> BitArray {
  encode.message([
    encode.int64_field(1, timestamp.seconds),
    encode.int32_field(2, timestamp.nanos),
  ])
}

fn oneof_response_decoder() -> decode.Decoder(
  option.Option(ServiceResponseResponse),
) {
  decode.from_field_dict(fn(fields) {
    case dict.get(fields, 1) {
      Ok([field, ..]) -> {
        case decode.message_field(_, eventmessage_decoder())(field) {
          Ok(value) -> Ok(option.Some(Data(value)))
          Error(_) -> {
            case dict.get(fields, 2) {
              Ok([field, ..]) -> {
                case decode.message_field(_, empty_decoder())(field) {
                  Ok(value) -> Ok(option.Some(EmptyData(value)))
                  Error(_) -> Ok(option.None)
                }
              }
              _ -> Ok(option.None)
            }
          }
        }
      }
      _ -> {
        case dict.get(fields, 2) {
          Ok([field, ..]) -> {
            case decode.message_field(_, empty_decoder())(field) {
              Ok(value) -> Ok(option.Some(EmptyData(value)))
              Error(_) -> Ok(option.None)
            }
          }
          _ -> Ok(option.None)
        }
      }
    }
  })
}

pub fn serviceresponse_decoder() -> decode.Decoder(ServiceResponse) {
  use response <- decode.then(oneof_response_decoder())
  decode.success(ServiceResponse(response: response))
}

pub fn decode_serviceresponse(
  data: BitArray,
) -> Result(ServiceResponse, List(decode.DecodeError)) {
  decode.run(data, serviceresponse_decoder())
}

pub fn eventmessage_decoder() -> decode.Decoder(EventMessage) {
  use event_name <- decode.then(decode.string_with_default(1, ""))
  use occurred_at <- decode.then(decode.nested_message(2, timestamp_decoder()))
  use duration <- decode.then(decode.nested_message(3, duration_decoder()))
  use update_mask <- decode.then(decode.nested_message(4, fieldmask_decoder()))
  decode.success(EventMessage(
    event_name: event_name,
    occurred_at: occurred_at,
    duration: duration,
    update_mask: update_mask,
  ))
}

pub fn decode_eventmessage(
  data: BitArray,
) -> Result(EventMessage, List(decode.DecodeError)) {
  decode.run(data, eventmessage_decoder())
}

pub fn duration_decoder() -> decode.Decoder(Duration) {
  use seconds <- decode.then(decode.int64_with_default(1, 0))
  use nanos <- decode.then(decode.int32_with_default(2, 0))
  decode.success(Duration(seconds: seconds, nanos: nanos))
}

pub fn decode_duration(
  data: BitArray,
) -> Result(Duration, List(decode.DecodeError)) {
  decode.run(data, duration_decoder())
}

pub fn empty_decoder() -> decode.Decoder(Empty) {
  decode.success(Empty)
}

pub fn decode_empty(data: BitArray) -> Result(Empty, List(decode.DecodeError)) {
  decode.run(data, empty_decoder())
}

pub fn fieldmask_decoder() -> decode.Decoder(FieldMask) {
  use paths <- decode.then(decode.repeated_string(1))
  decode.success(FieldMask(paths: paths))
}

pub fn decode_fieldmask(
  data: BitArray,
) -> Result(FieldMask, List(decode.DecodeError)) {
  decode.run(data, fieldmask_decoder())
}

pub fn timestamp_decoder() -> decode.Decoder(Timestamp) {
  use seconds <- decode.then(decode.int64_with_default(1, 0))
  use nanos <- decode.then(decode.int32_with_default(2, 0))
  decode.success(Timestamp(seconds: seconds, nanos: nanos))
}

pub fn decode_timestamp(
  data: BitArray,
) -> Result(Timestamp, List(decode.DecodeError)) {
  decode.run(data, timestamp_decoder())
}
