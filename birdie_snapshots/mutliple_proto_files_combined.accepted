---
version: 1.4.1
title: Mutliple proto files combined
file: ./test/protozoa_dev_test.gleam
test_name: multiple_proto_files_combined_test
---
//// Generated by Protozoa from common.proto, test/proto/imports.proto
//// 
//// This file is auto-generated and can be safely deleted and regenerated.
//// To regenerate all proto files, run: gleam run -m protozoa
//// 
//// DO NOT EDIT THIS FILE MANUALLY - all changes will be lost on regeneration.

import gleam/int
import gleam/list
import gleam/result
import gleam/string
import protozoa/decode
import protozoa/encode
import protozoa/wire

pub type Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

pub type Address {
  Address(
    street: String,
    city: String,
    postal_code: String,
    country: String,
  )
}

pub type Timestamp {
  Timestamp(
    seconds: Int,
    nanos: Int,
  )
}

pub type Person {
  Person(
    name: String,
    age: Int,
    address: common.testcommonAddress,
    priority: common.testcommonPriority,
    created_at: common.testcommonTimestamp,
  )
}

pub type Organization {
  Organization(
    name: String,
    members: List(Person),
    headquarters: common.testcommonAddress,
  )
}

pub fn encode_timestamp(timestamp: Timestamp) -> BitArray {
  encode.message([
    encode.int64_field(1, timestamp.seconds),
    encode.int32_field(2, timestamp.nanos),
  ])
}

pub fn encode_address(address: Address) -> BitArray {
  encode.message([
    encode.string_field(1, address.street),
    encode.string_field(2, address.city),
    encode.string_field(3, address.postal_code),
    encode.string_field(4, address.country),
  ])
}

pub fn encode_organization(organization: Organization) -> BitArray {
  let members_fields = list.map(organization.members, fn(v) { encode.field(2, wire.LengthDelimited, encode.length_delimited(encode_person(v))) })
  encode.message(list.flatten([members_fields, [encode.string_field(1, organization.name)], [encode.field(3, wire.LengthDelimited, encode.length_delimited(encode_testcommonaddress(organization.headquarters)))]]))
}

pub fn encode_person(person: Person) -> BitArray {
  encode.message([
    encode.string_field(1, person.name),
    encode.int32_field(2, person.age),
    encode.field(3, wire.LengthDelimited, encode.length_delimited(encode_testcommonaddress(person.address))),
    encode.field(4, wire.LengthDelimited, encode.length_delimited(encode_testcommonpriority(person.priority))),
    encode.field(5, wire.LengthDelimited, encode.length_delimited(encode_testcommontimestamp(person.created_at))),
  ])
}

pub fn timestamp_decoder() -> decode.Decoder(Timestamp) {
  use seconds <- decode.then(decode.int64_with_default(1, 0))
  use nanos <- decode.then(decode.int32_with_default(2, 0))
  decode.success(Timestamp(seconds: seconds, nanos: nanos))
}

pub fn decode_timestamp(data: BitArray) -> Result(Timestamp, List(decode.DecodeError)) {
  decode.run(data, timestamp_decoder())
}

pub fn address_decoder() -> decode.Decoder(Address) {
  use street <- decode.then(decode.string_with_default(1, ""))
  use city <- decode.then(decode.string_with_default(2, ""))
  use postal_code <- decode.then(decode.string_with_default(3, ""))
  use country <- decode.then(decode.string_with_default(4, ""))
  decode.success(Address(street: street, city: city, postal_code: postal_code, country: country))
}

pub fn decode_address(data: BitArray) -> Result(Address, List(decode.DecodeError)) {
  decode.run(data, address_decoder())
}

pub fn organization_decoder() -> decode.Decoder(Organization) {
  use name <- decode.then(decode.string_with_default(1, ""))
  use members <- decode.then(decode.repeated_field(2, fn(field) { decode.message_field(_, person_decoder())(field) }))
  use headquarters <- decode.then(decode.nested_message(3, testcommonaddress_decoder()))
  decode.success(Organization(name: name, members: members, headquarters: headquarters))
}

pub fn decode_organization(data: BitArray) -> Result(Organization, List(decode.DecodeError)) {
  decode.run(data, organization_decoder())
}

pub fn person_decoder() -> decode.Decoder(Person) {
  use name <- decode.then(decode.string_with_default(1, ""))
  use age <- decode.then(decode.int32_with_default(2, 0))
  use address <- decode.then(decode.nested_message(3, testcommonaddress_decoder()))
  use priority <- decode.then(decode.nested_message(4, testcommonpriority_decoder()))
  use created_at <- decode.then(decode.nested_message(5, testcommontimestamp_decoder()))
  decode.success(Person(
    name: name,
    age: age,
    address: address,
    priority: priority,
    created_at: created_at,
  ))
}

pub fn decode_person(data: BitArray) -> Result(Person, List(decode.DecodeError)) {
  decode.run(data, person_decoder())
}

pub fn encode_priority_value(value: Priority) -> Int {
  case value {
    LOW -> 0
    MEDIUM -> 1
    HIGH -> 2
    URGENT -> 3
  }
}

pub fn decode_priority_field(field_num: Int) -> decode.Decoder(Priority) {
  decode.field(field_num, fn(field) {
    use value <- result.try(decode.int32_field(field))
    case value {
          0 -> Ok(LOW)
          1 -> Ok(MEDIUM)
          2 -> Ok(HIGH)
          3 -> Ok(URGENT)
      _ -> Error(decode.DecodeError(expected: "valid priority value", found: "Unknown priority value: " <> string.inspect(value), path: []))
    }
  })
}

fn decode_priority_from_field(field: decode.Field) -> Result(Priority, decode.DecodeError) {
  use value <- result.try(decode.int32_field(field))
  case value {
      0 -> Ok(LOW)
      1 -> Ok(MEDIUM)
      2 -> Ok(HIGH)
      3 -> Ok(URGENT)
    _ -> Error(decode.DecodeError(expected: "valid priority value", found: "Unknown priority value: " <> string.inspect(value), path: []))
  }
}

pub fn decode_priority_value(value: Int) -> Result(Priority, String) {
  case value {
    0 -> Ok(LOW)
    1 -> Ok(MEDIUM)
    2 -> Ok(HIGH)
    3 -> Ok(URGENT)
    _ -> Error("Unknown priority value: " <> int.to_string(value))
  }
}

pub fn decode_repeated_priority(field_num: Int) -> decode.Decoder(List(Priority)) {
  decode.repeated_field(field_num, fn(field) {
    use value <- result.try(decode.int32_field(field))
    decode_priority_value(value)
    |> result.map_error(fn(err) { decode.DecodeError(expected: "priority", found: err, path: []) })
  })
}
